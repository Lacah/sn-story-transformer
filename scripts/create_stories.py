#!/usr/bin/env python3
"""
create_stories.py — stories.json → ServiceNow Agile 2.0

Reads stories.json (generated by analyze_doc.py) and schema.yaml, then creates
Epics and User Stories in an existing Agile 2.0 product via the ServiceNow Table API.

Usage:
    python create_stories.py --instance https://xxx.service-now.com \\
                             --client-id <id> --client-secret <secret> \\
                             --product <product_sys_id>

    # Or via environment variables (see .env.example):
    python create_stories.py

    # Preview without creating anything:
    python create_stories.py --dry-run

    # Patch descriptions of already-created stories (matched by short_description):
    python create_stories.py --update

Authentication (set SERVICENOW_AUTH in .env):
    SERVICENOW_AUTH=oauth (default)  — OAuth 2.0 client credentials grant
        requires: SERVICENOW_CLIENT_ID + SERVICENOW_CLIENT_SECRET
    SERVICENOW_AUTH=basic            — HTTP Basic auth
        requires: SERVICENOW_USERNAME + SERVICENOW_PASSWORD

Requirements:
    pip install requests pyyaml python-dotenv
"""

import argparse
import json
import os
import sys
from typing import Iterator, Optional, Union

try:
    import requests
except ImportError:
    sys.exit("Missing dependency: pip install requests")

try:
    import yaml
except ImportError:
    sys.exit("Missing dependency: pip install pyyaml")

try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass


SCRIPT_DIR  = os.path.dirname(os.path.abspath(__file__))
SCHEMA_FILE = os.path.join(SCRIPT_DIR, "schema.yaml")
STORIES_FILE = os.path.join(SCRIPT_DIR, "stories.json")


# ---------------------------------------------------------------------------
# Data loading
# ---------------------------------------------------------------------------

def load_schema() -> dict:
    if not os.path.exists(SCHEMA_FILE):
        sys.exit(
            f"\nschema.yaml not found at: {SCHEMA_FILE}\n"
            "Make sure schema.yaml is in the same directory as this script."
        )
    with open(SCHEMA_FILE) as f:
        return yaml.safe_load(f)


def load_stories() -> dict:
    if not os.path.exists(STORIES_FILE):
        sys.exit(
            f"\nstories.json not found at: {STORIES_FILE}\n"
            "Run analyze_doc.py first to generate it:\n\n"
            "    python analyze_doc.py --input <your_document.md>\n"
        )
    with open(STORIES_FILE) as f:
        return json.load(f)


def iter_stories(data: dict) -> Iterator[dict]:
    """Yield each story from the nested epics structure."""
    for epic in data.get("epics", []):
        for story in epic.get("stories", []):
            yield story


# ---------------------------------------------------------------------------
# Payload builders
# ---------------------------------------------------------------------------

def _format_html_list(items: Union[list[str], str]) -> str:
    """Render a list of strings as an HTML unordered list."""
    if isinstance(items, list):
        lis = "".join(f"<li>{item}</li>" for item in items)
        return f"<ul>{lis}</ul>"
    return str(items)  # already a string (e.g. manually edited stories.json)


def build_epic_payload(epic: dict, schema: dict, product_sys_id: str) -> dict:
    payload = {"product": product_sys_id}
    for field in schema["tables"]["epic"]["fields"]:
        fname = field["name"]
        if "default" in field:
            payload[fname] = field["default"]
        if fname in epic:
            payload[fname] = epic[fname]
    return payload


def build_story_payload(story: dict, schema: dict, product_sys_id: str, epic_sys_id: str) -> dict:
    payload = {"product": product_sys_id, "epic": epic_sys_id}
    for field in schema["tables"]["story"]["fields"]:
        fname = field["name"]
        if "default" in field:
            payload[fname] = field["default"]
        if fname not in story:
            continue
        value = story[fname]
        if field.get("format") == "html_list":
            payload[fname] = _format_html_list(value)
        elif "mapping" in field:
            lookup = schema.get(field["mapping"], {})
            payload[fname] = lookup.get(value, {}).get("value", value)
        else:
            payload[fname] = value
    return payload


def build_story_patch_payload(story: dict, schema: dict) -> dict:
    """Build a patch payload — content fields only, no relationships or defaults."""
    payload = {}
    for field in schema["tables"]["story"]["fields"]:
        fname = field["name"]
        if "default" in field or fname not in story:
            continue
        value = story[fname]
        if field.get("format") == "html_list":
            payload[fname] = _format_html_list(value)
        elif "mapping" in field:
            lookup = schema.get(field["mapping"], {})
            payload[fname] = lookup.get(value, {}).get("value", value)
        else:
            payload[fname] = value
    return payload


def priority_label(story: dict, schema: dict) -> str:
    key = story.get("priority", "")
    return schema.get("priorities", {}).get(key, {}).get("label", key or "?")


# ---------------------------------------------------------------------------
# API helpers
# ---------------------------------------------------------------------------

def get_oauth_token(base_url: str, client_id: str, client_secret: str) -> str:
    """Exchange client credentials for an OAuth Bearer token (client_credentials grant)."""
    client_id     = client_id.strip()
    client_secret = client_secret.strip()

    url = f"{base_url}/oauth_token.do"
    response = requests.post(url, data={
        "grant_type":    "client_credentials",
        "client_id":     client_id,
        "client_secret": client_secret,
    })
    if response.status_code != 200:
        non_printable_id     = sum(1 for c in client_id     if ord(c) < 32 or ord(c) > 126)
        non_printable_secret = sum(1 for c in client_secret if ord(c) < 32 or ord(c) > 126)
        sys.exit(
            f"OAuth token request failed ({response.status_code}): {response.text}\n\n"
            f"Credential debug (after strip):\n"
            f"  client_id     : {len(client_id)} chars, {non_printable_id} non-printable\n"
            f"  client_secret : {len(client_secret)} chars, {non_printable_secret} non-printable\n\n"
            "ServiceNow checklist:\n"
            "  1. System OAuth > Application Registry — entry exists and is Active\n"
            "  2. Grant type 'Client Credentials' is ticked on that entry\n"
            "  3. OAuth plugin (com.snc.integration.oauth) is active\n"
            "  4. The OAuth endpoint /oauth_token.do is not blocked by an ACL\n"
        )
    return response.json()["access_token"]


def get_session(args: argparse.Namespace, base_url: str) -> "requests.Session":
    """Build an authenticated requests.Session based on SERVICENOW_AUTH."""
    auth_type = os.getenv("SERVICENOW_AUTH", "oauth").strip().lower()
    session = requests.Session()
    session.headers.update({
        "Content-Type": "application/json",
        "Accept":       "application/json",
    })
    if auth_type == "basic":
        session.auth = (args.username, args.password)
        print("  Using Basic authentication.\n")
    else:
        print("Obtaining OAuth token ...")
        token = get_oauth_token(base_url, args.client_id, args.client_secret)
        print("  Token obtained.\n")
        session.headers["Authorization"] = f"Bearer {token}"
    return session


def api_post(session: "requests.Session", base_url: str, table: str, payload: dict) -> dict:
    url = f"{base_url}/api/now/table/{table}"
    response = session.post(url, json=payload)
    response.raise_for_status()
    return response.json()["result"]


def api_patch(session: "requests.Session", base_url: str, table: str,
              sys_id: str, payload: dict) -> dict:
    url = f"{base_url}/api/now/table/{table}/{sys_id}"
    response = session.patch(url, json=payload)
    response.raise_for_status()
    return response.json()["result"]


def api_get(session: "requests.Session", base_url: str, table: str, sys_id: str) -> dict:
    url = f"{base_url}/api/now/table/{table}/{sys_id}"
    response = session.get(url)
    response.raise_for_status()
    return response.json()["result"]


def api_probe(session: "requests.Session", base_url: str, table: str) -> tuple[bool, str]:
    """Check whether a table is accessible. Returns (ok, message)."""
    url = f"{base_url}/api/now/table/{table}?sysparm_limit=1&sysparm_fields=sys_id"
    response = session.get(url)
    if response.status_code == 200:
        return True, "OK"
    return False, f"HTTP {response.status_code} — {response.text[:120]}"


def preflight_check(session: "requests.Session", base_url: str,
                    product_sys_id: str, schema: dict) -> None:
    """Verify all required tables are reachable and the target product exists."""
    print("Pre-flight checks ...")
    all_ok = True

    epic_table  = schema["tables"]["epic"]["name"]
    story_table = schema["tables"]["story"]["name"]

    for table in (epic_table, story_table):
        ok, msg = api_probe(session, base_url, table)
        status  = "OK" if ok else f"FAIL — {msg}"
        print(f"  Table {table:<40} {status}")
        if not ok:
            all_ok = False

    product_table = "cmdb_application_product_model"
    ok, msg = api_probe(session, base_url, product_table)
    status  = "OK" if ok else f"FAIL — {msg}"
    print(f"  Table {product_table:<40} {status}")
    if not ok:
        all_ok = False

    if not all_ok:
        sys.exit("\nPre-flight failed — fix the issues above before running for real.")

    try:
        product = api_get(session, base_url, product_table, product_sys_id)
        name    = product.get("name") or product.get("short_description") or product_sys_id
        print(f"  Product record found: {name}")
    except requests.HTTPError as exc:
        sys.exit(
            f"\nCould not fetch product {product_sys_id} from {product_table}: {exc}\n"
            "Make sure the sys_id is correct and your user has read access."
        )

    print()


# ---------------------------------------------------------------------------
# Main modes
# ---------------------------------------------------------------------------

def dry_run(data: dict, schema: dict, product_sys_id: Optional[str]) -> None:
    epics   = data.get("epics", [])
    stories = list(iter_stories(data))

    print("\n=== DRY RUN — no records will be created ===\n")
    print(f"Target product sys_id : {product_sys_id or '(not provided)'}")
    print(f"Epic table            : {schema['tables']['epic']['name']}")
    print(f"Story table           : {schema['tables']['story']['name']}\n")

    print(f"Would create {len(epics)} epics:")
    for epic in epics:
        count = len(epic.get("stories", []))
        print(f"  {epic['short_description']} ({count} stories)")

    print(f"\nWould create {len(stories)} stories:")
    for story in stories:
        gap   = f"[{story['gap_id']}] " if story.get("gap_id") else ""
        label = priority_label(story, schema)
        print(f"  {gap}{story['short_description']}  [{label}]")

    print("\n=== End of dry run ===\n")


def update_stories(session: "requests.Session", base_url: str,
                   product_sys_id: str, data: dict, schema: dict) -> None:
    """Patch content fields on existing stories matched by short_description."""
    story_table = schema["tables"]["story"]["name"]

    print(f"Fetching existing stories for product {product_sys_id} ...")
    url = (
        f"{base_url}/api/now/table/{story_table}"
        f"?sysparm_query=product={product_sys_id}"
        f"&sysparm_fields=sys_id,short_description"
        f"&sysparm_limit=500"
    )
    response = session.get(url)
    response.raise_for_status()
    existing = {r["short_description"]: r["sys_id"] for r in response.json()["result"]}
    print(f"  Found {len(existing)} existing stories.\n")

    updated, skipped = 0, 0
    for story in iter_stories(data):
        sys_id = existing.get(story["short_description"])
        if not sys_id:
            gap = f"[{story['gap_id']}] " if story.get("gap_id") else ""
            print(f"  SKIP  {gap}'{story['short_description']}' — not found in product")
            skipped += 1
            continue

        patch = build_story_patch_payload(story, schema)
        api_patch(session, base_url, story_table, sys_id, patch)
        gap = f"[{story['gap_id']}] " if story.get("gap_id") else ""
        print(f"  Updated  {gap}{story['short_description']}")
        print(f"    URL: {base_url}/nav_to.do?uri={story_table}.do?sys_id={sys_id}")
        updated += 1

    print(f"\n=== Update complete: {updated} updated, {skipped} skipped ===")


def create_all(session: "requests.Session", base_url: str,
               product_sys_id: str, data: dict, schema: dict) -> None:
    """Create all epics and their nested stories."""
    epics       = data.get("epics", [])
    epic_table  = schema["tables"]["epic"]["name"]
    story_table = schema["tables"]["story"]["name"]

    print(f"Creating {len(epics)} epics ...")
    total_stories = 0

    for epic in epics:
        payload    = build_epic_payload(epic, schema, product_sys_id)
        result     = api_post(session, base_url, epic_table, payload)
        epic_sys_id = result["sys_id"]
        stories    = epic.get("stories", [])
        print(f"  Created epic: {epic['short_description']} ({len(stories)} stories)")
        print(f"    URL: {base_url}/nav_to.do?uri={epic_table}.do?sys_id={epic_sys_id}")

        for story in stories:
            payload = build_story_payload(story, schema, product_sys_id, epic_sys_id)
            result  = api_post(session, base_url, story_table, payload)
            sys_id  = result["sys_id"]
            gap     = f"[{story['gap_id']}] " if story.get("gap_id") else ""
            label   = priority_label(story, schema)
            print(f"    [{label}] {gap}{story['short_description']}")
            print(f"      URL: {base_url}/nav_to.do?uri={story_table}.do?sys_id={sys_id}")
            total_stories += 1

    print(f"\n=== Done: {len(epics)} epics, {total_stories} stories created ===")
    print(f"\nOpen your Agile 2.0 board to see the new backlog items.")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Push stories.json to ServiceNow Agile 2.0 as Epics and Stories."
    )
    parser.add_argument("--instance",      default=os.getenv("SERVICENOW_INSTANCE"),
                        help="ServiceNow instance base URL (e.g. https://xxx.service-now.com)")
    parser.add_argument("--client-id",     default=os.getenv("SERVICENOW_CLIENT_ID"),
                        help="OAuth client ID — required when SERVICENOW_AUTH=oauth (default)")
    parser.add_argument("--client-secret", default=os.getenv("SERVICENOW_CLIENT_SECRET"),
                        help="OAuth client secret — required when SERVICENOW_AUTH=oauth (default)")
    parser.add_argument("--username",      default=os.getenv("SERVICENOW_USERNAME"),
                        help="Username — required when SERVICENOW_AUTH=basic")
    parser.add_argument("--password",      default=os.getenv("SERVICENOW_PASSWORD"),
                        help="Password — required when SERVICENOW_AUTH=basic")
    parser.add_argument("--product",       default=os.getenv("SERVICENOW_PRODUCT_SYS_ID"),
                        help="sys_id of the existing Agile 2.0 product")
    parser.add_argument("--dry-run",  action="store_true",
                        help="Print what would be created without making any API calls")
    parser.add_argument("--update",   action="store_true",
                        help="Patch content fields on already-created stories "
                             "(matched by short_description within the product)")
    return parser.parse_args()


def validate_args(args: argparse.Namespace) -> None:
    auth_type = os.getenv("SERVICENOW_AUTH", "oauth").strip().lower()
    if auth_type == "basic":
        required = [
            ("--instance",  args.instance),
            ("--username",  args.username),
            ("--password",  args.password),
            ("--product",   args.product),
        ]
    else:
        required = [
            ("--instance",      args.instance),
            ("--client-id",     args.client_id),
            ("--client-secret", args.client_secret),
            ("--product",       args.product),
        ]
    missing = [name for name, val in required if not val]
    if missing and not args.dry_run:
        sys.exit(
            f"Missing required arguments: {', '.join(missing)}\n"
            "Set them via CLI flags or the corresponding SERVICENOW_* environment variables.\n"
            "See .env.example for details."
        )


def main() -> None:
    args   = parse_args()
    schema = load_schema()
    data   = load_stories()

    validate_args(args)

    if args.dry_run:
        dry_run(data, schema, args.product)
        return

    base_url = args.instance.rstrip("/")

    print(f"\n=== create_stories.py ===\n")
    print(f"  Stories file : {STORIES_FILE}")
    print(f"  Instance     : {base_url}")
    print(f"  Product      : {args.product}\n")

    session = get_session(args, base_url)

    preflight_check(session, base_url, args.product, schema)

    if args.update:
        update_stories(session, base_url, args.product, data, schema)
    else:
        create_all(session, base_url, args.product, data, schema)


if __name__ == "__main__":
    main()
